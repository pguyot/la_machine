#!/usr/bin/env escript
%% -*- erlang -*-
%%! +A0

%%-----------------------------------------------------------------------------
%% @doc Create an uncompressed ZIP archive from the sounds directory and
%% generate a pre-compiled index header file.
%%
%% Uses environment variable (from rebar):
%% - `REBAR_ROOT_DIR': Root directory containing sounds/
%%-----------------------------------------------------------------------------
main(_Args) ->
    case os:getenv("REBAR_ROOT_DIR") of
        false ->
            io:format(standard_error, "Error: REBAR_ROOT_DIR not set~n", []),
            erlang:halt(1);
        RootDir ->
            BuildDir = filename:join([RootDir, "_build", "generated"]),
            SoundsDir = filename:join(RootDir, "sounds"),
            case create_sounds_partition(SoundsDir, BuildDir) of
                ok ->
                    ok;
                {error, {not_dir, Dir}} ->
                    io:format(standard_error, "Error: ~s is not a directory\n", [Dir]),
                    erlang:halt(1);
                {error, {no_aac_found, Dir}} ->
                    io:format(standard_error, "Error: no .aac sound were found in ~s\n", [Dir]),
                    erlang:halt(1);
                {error, {zip_create_error, Reason}} ->
                    io:format(standard_error, "Error: zip creation failed (~p)\n", [Reason]),
                    erlang:halt(1);
                {error, Other} ->
                    io:format(standard_error, "Error: ~p\n", [Other]),
                    erlang:halt(1)
            end
    end.

create_sounds_partition(SoundsDir, BuildDir) ->
    maybe
        {ok, ZipBinary} ?= create_sounds_zip(SoundsDir),
        Index = build_index(ZipBinary),
        OutputBin = filename:join(BuildDir, "sounds.bin"),
        OutputHrl = filename:join(BuildDir, "la_machine_sounds_index.hrl"),
        ok ?= file:write_file(OutputBin, ZipBinary),
        ok ?= write_index_hrl(OutputHrl, Index)
    end.

create_sounds_zip(SoundsDir) ->
    maybe
        ok ?=
            case filelib:is_dir(SoundsDir) of
                false ->
                    {error, {not_dir, SoundsDir}};
                true ->
                    ok
            end,
        Files = find_aac_files(SoundsDir),
        ok ?=
            case Files of
                [] ->
                    {error, {no_aac_found, SoundsDir}};
                _ ->
                    ok
            end,
        ZipEntries = lists:map(
            fun(FullPath) ->
                RelPath = make_relative_path(FullPath, SoundsDir),
                {ok, Content} = file:read_file(FullPath),
                {RelPath, Content}
            end,
            Files
        ),
        %% No compression (store only)
        case zip:create("sounds.zip", ZipEntries, [{compress, []}, memory]) of
            {ok, {"sounds.zip", Binary}} ->
                {ok, Binary};
            {error, Reason} ->
                {error, {zip_create_error, Reason}}
        end
    end.

%%-----------------------------------------------------------------------------
%% Index building — use zip:table/1 to list entries, then read local headers
%% to compute the actual data offsets.
%%-----------------------------------------------------------------------------

-define(LOCAL_FILE_HEADER_SIG, 16#04034b50).
-define(LOCAL_FILE_HEADER_SIZE, 30).

%% @doc Build an index of {Filename, {DataOffset, DataSize}} from a ZIP binary.
build_index(ZipBinary) ->
    {ok, Table} = zip:table(ZipBinary),
    lists:filtermap(
        fun
            ({zip_file, Filename, _FileInfo, _Comment, LocalHeaderOffset, UncompressedSize}) ->
                DataOffset = compute_data_offset(ZipBinary, LocalHeaderOffset),
                FilenameBin = list_to_binary(Filename),
                {true, {FilenameBin, {DataOffset, UncompressedSize}}};
            ({zip_comment, _}) ->
                false
        end,
        Table
    ).

%% @doc Compute the offset of the actual file data from a local file header.
compute_data_offset(ZipBinary, LocalHeaderOffset) ->
    <<?LOCAL_FILE_HEADER_SIG:32/little, _VersionNeeded:16/little, _Flags:16/little,
        _CompressionMethod:16/little, _ModTime:16/little, _ModDate:16/little, _CRC32:32/little,
        _CompressedSize:32/little, _UncompressedSize:32/little, FilenameLen:16/little,
        ExtraLen:16/little,
        _/binary>> =
        binary:part(ZipBinary, LocalHeaderOffset, ?LOCAL_FILE_HEADER_SIZE),
    LocalHeaderOffset + ?LOCAL_FILE_HEADER_SIZE + FilenameLen + ExtraLen.

%%-----------------------------------------------------------------------------
%% .hrl generation
%%-----------------------------------------------------------------------------

write_index_hrl(OutputHrl, Index) ->
    Header =
        <<
            "%% Generated by create_sounds_partition.escript — do not edit.\n"
            "-define(SOUNDS_INDEX, #{\n"
        >>,
    Entries = format_index_entries(Index),
    Footer = <<"}).\n">>,
    Content = list_to_binary([Header, Entries, Footer]),
    case file:read_file(OutputHrl) of
        {ok, Content} ->
            ok;
        _ ->
            file:write_file(OutputHrl, Content)
    end.

format_index_entries(Index) ->
    format_index_entries(Index, []).

format_index_entries([], Acc) ->
    lists:reverse(Acc);
format_index_entries([{Filename, {DataOffset, DataSize}}], Acc) ->
    Line = io_lib:format("    <<~p>> => {~B, ~B}\n", [
        binary_to_list(Filename), DataOffset, DataSize
    ]),
    lists:reverse([list_to_binary([Line]) | Acc]);
format_index_entries([{Filename, {DataOffset, DataSize}} | Rest], Acc) ->
    Line = io_lib:format("    <<~p>> => {~B, ~B},\n", [
        binary_to_list(Filename), DataOffset, DataSize
    ]),
    format_index_entries(Rest, [list_to_binary([Line]) | Acc]).

%%-----------------------------------------------------------------------------
%% File utilities
%%-----------------------------------------------------------------------------

%% @doc Find all .aac files recursively in the given directory.
find_aac_files(Dir) ->
    find_aac_files(Dir, []).

find_aac_files(Dir, Acc) ->
    case file:list_dir(Dir) of
        {ok, Entries} ->
            lists:foldl(
                fun(Entry, AccIn) ->
                    FullPath = filename:join(Dir, Entry),
                    case filelib:is_dir(FullPath) of
                        true ->
                            find_aac_files(FullPath, AccIn);
                        false ->
                            case filename:extension(Entry) of
                                ".aac" -> [FullPath | AccIn];
                                _ -> AccIn
                            end
                    end
                end,
                Acc,
                Entries
            );
        {error, _} ->
            Acc
    end.

%% @doc Make a path relative to the base directory.
%% Returns a string like "poke/00202.aac"
make_relative_path(FullPath, BaseDir) ->
    FullPathNorm = filename:absname(FullPath),
    BaseDirNorm = filename:absname(BaseDir),
    case string:prefix(FullPathNorm, BaseDirNorm) of
        nomatch ->
            filename:basename(FullPath);
        RelPath ->
            case RelPath of
                [$/ | Rest] -> Rest;
                Rest -> Rest
            end
    end.
